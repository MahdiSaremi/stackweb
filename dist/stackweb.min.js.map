{
  "version": 3,
  "sources": ["../js/index.ts"],
  "sourcesContent": ["abstract class Entity {\n\n    parent: Entity\n    parentE: Entity\n    el: Element\n    isMounted = false\n\n    protected abstract onMount(): void\n\n    protected abstract onUnmount(): void\n\n    protected abstract onMorph(other: Entity): void\n\n    public mount(parent: Entity, parentE: Entity, el: Element) {\n        this.parent = parent\n        this.parentE = parentE\n        this.el = el\n        this.isMounted = false\n        this.onMount()\n        this.isMounted = true\n    }\n\n    public unmount() {\n        this.onUnmount()\n        this.isMounted = false\n    }\n\n    public morph(other: Entity) {\n        if (this.isStatic) return\n\n        this.onMorph(other)\n    }\n\n\n    isStatic: boolean = false\n    public static() {\n        this.isStatic = true\n        return this\n    }\n\n\n    public abstract resolveRelativeNodes(): [Node, Node]\n\n    public abstract resolveNextNodeOf(child: Entity): Node\n\n\n    protected insertNode(node: Node) {\n        if (this.parentE.isMounted) {\n            let nextOfMe = this.parent.resolveNextNodeOf(this)\n            if (nextOfMe) {\n                this.parent.el.insertBefore(node, nextOfMe)\n            } else {\n                this.parent.el.appendChild(node)\n            }\n        } else {\n            this.parent.el.appendChild(node)\n        }\n    }\n\n}\n\nclass Root extends Entity {\n    source: Group\n\n    constructor(source: Group) {\n        super();\n        this.source = source\n    }\n\n    protected onMount() {\n        this.source.mount(this, this, this.el)\n    }\n\n    protected onUnmount() {\n        this.source.unmount()\n    }\n\n    onMorph(other: Entity) {\n        this.source.morph((other as Root).source)\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        return this.source.resolveRelativeNodes()\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        return undefined\n    }\n}\n\nclass Group extends Entity {\n    source: Array<Entity>\n\n    constructor(source: Array<Entity>) {\n        super()\n        this.source = source\n    }\n\n    onMount() {\n        for (const i in this.source) {\n            this.source[i].mount(this, this.parentE, this.el)\n        }\n    }\n\n    onUnmount() {\n        for (const i in this.source) {\n            this.source[i].unmount()\n        }\n    }\n\n    onMorph(other: Entity) {\n        for (const i in this.source) {\n            this.source[i].morph((other as Group).source[i])\n        }\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        if (this.source.length == 0) {\n            return [undefined, undefined]\n        } else if (this.source.length == 1) {\n            return this.source[0].resolveRelativeNodes()\n        } else {\n            let a, b, i\n\n            // Todo : Should save in array to better performance\n            for (i = 0; i < this.source.length; i++) {\n                let cur = this.source[i].resolveRelativeNodes()\n                if (cur[0] || cur[1]) {\n                    a = cur[0] ?? cur[1]\n                    break\n                }\n            }\n            for (i = this.source.length - 1; i >= 0; i--) {\n                let cur = this.source[i].resolveRelativeNodes()\n                if (cur[0] || cur[1]) {\n                    b = cur[1] ?? cur[0]\n                    break\n                }\n            }\n\n            return [a, b]\n        }\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        let index = this.source.indexOf(child)\n        for (let i = index + 1; i < this.source.length; i++) {\n            let cur = this.source[i].resolveRelativeNodes()\n            if (cur[0] || cur[1]) {\n                return cur[0] ?? cur[1]\n            }\n        }\n\n        if (this.parent) {\n            return this.parent.resolveNextNodeOf(this)\n        }\n\n        return undefined\n    }\n}\n\ninterface DomRegister {\n    name: string\n    attrs: Object\n    slot: Group\n}\n\nclass Dom extends Entity {\n    source: DomRegister\n\n    constructor(source: DomRegister) {\n        super()\n        this.source = source\n    }\n\n    onMount() {\n        this.el = document.createElement(this.source.name)\n\n        this.insertNode(this.el)\n\n        this.source.slot.mount(this, this, this.el)\n    }\n\n    onUnmount() {\n        this.el.remove()\n        this.el = undefined\n    }\n\n    onMorph(other: Entity) {\n        this.source.slot.morph((other as Dom).source.slot)\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        return [this.el, this.el];\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        return undefined;\n    }\n}\n\nclass Text extends Entity {\n    node: Node\n    value: string\n\n    constructor(value: string) {\n        super();\n        this.value = value\n    }\n\n    onMount() {\n        this.node = document.createTextNode(this.value)\n        this.insertNode(this.node)\n    }\n\n    onUnmount() {\n        this.el.removeChild(this.node)\n        this.node = undefined\n    }\n\n    onMorph(other: Entity) {\n        this.value = (other as Text).value\n        this.node.textContent = this.value\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        return [this.node, this.node];\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        return undefined;\n    }\n}\n\nclass HelloWorld extends Entity {\n    node: Node\n\n    onMount() {\n        this.node = document.createTextNode('Hello World (' + Math.floor(Math.random() * 100) + ')')\n        this.insertNode(this.node)\n    }\n\n    onUnmount() {\n        this.el.removeChild(this.node)\n        this.node = undefined\n    }\n\n    onMorph(other: Entity) {\n        this.node.textContent = 'Hello World (' + Math.floor(Math.random() * 100) + ')'\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        return [this.node, this.node];\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        return undefined;\n    }\n}\n\ninterface ComponentRegister {\n    states: ($: Invoke) => Object\n    slot: ($: Invoke) => Group\n}\n\nclass Component {\n    source: ComponentRegister\n\n    constructor(source: ComponentRegister) {\n        this.source = source\n    }\n\n    // Modes: 0 - Never Morph, 1 - Always Morph, 2 - Morph When\n    morphMode: number = 0\n    morphCond: boolean\n\n    public morphType(mode: number, condition?: boolean) {\n        this.morphMode = mode\n        this.morphCond = condition\n        return this\n    }\n}\n\nclass Invoke extends Entity {\n    component: Component\n    slots: Object\n    attrs: Object\n    states = {}\n    content: Group\n\n    constructor(component: Component, slots: Object, attrs: Object) {\n        super()\n        this.component = component\n        this.slots = slots\n        this.attrs = attrs\n    }\n\n    onMount() {\n        this.states = this.component.source.states(this)\n        this.content = this.component.source.slot(this)\n\n        this.content.mount(this, this.parentE, this.el)\n    }\n\n    onUnmount() {\n        this.content.unmount()\n    }\n\n    reset() {\n        this.states = this.component.source.states(this)\n    }\n\n    changed: boolean = false\n\n    refresh() {\n        const newSlot = this.component.source.slot(this)\n\n        this.content.morph(newSlot)\n\n        this.changed = false\n    }\n\n    onMorph(other: Entity) {\n        if (this.component.morphMode == 1 || (this.component.morphMode == 2 && this.component.morphCond)) {\n            this.content.morph((other as Invoke).content)\n        }\n    }\n\n    getState(name: string) {\n        return this.states[name]\n    }\n\n    setState(name: string, value: any) {\n        this.states[name] = value\n        this.changed = true\n    }\n\n    track(callback: () => any) {\n        callback()\n        if (this.changed) {\n            this.refresh()\n        }\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        return this.content.resolveRelativeNodes()\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        return this.parent.resolveNextNodeOf(this)\n    }\n}\n\nclass If extends Entity {\n    source: Group\n    condition: boolean\n\n    constructor(condition: boolean, source: Group) {\n        super()\n        this.source = source\n        this.condition = condition\n    }\n\n    onMount() {\n        if (this.condition) {\n            this.source.mount(this, this.parentE, this.el)\n        }\n    }\n\n    onUnmount() {\n        if (this.condition) {\n            this.source.unmount()\n        }\n    }\n\n    onMorph(other: Entity) {\n        let newCond = (other as If).condition\n\n        if (newCond != this.condition) {\n            if (newCond) {\n                this.source.mount(this, this.parentE, this.el)\n            } else {\n                this.source.onUnmount()\n            }\n\n            this.condition = newCond\n        }\n    }\n\n    resolveRelativeNodes(): [Node, Node] {\n        if (this.condition) {\n            return this.source.resolveRelativeNodes()\n        } else {\n            return [undefined, undefined];\n        }\n    }\n\n    resolveNextNodeOf(child: Entity): Node {\n        return this.parent.resolveNextNodeOf(this)\n    }\n}\n\nlet StackWeb = {\n    Entity,\n    Root,\n    Group,\n    Dom,\n    Text,\n    HelloWorld,\n    Component,\n    Invoke,\n    If,\n}\n\nwindow['StackWeb'] = StackWeb\n\nexport default StackWeb\n"],
  "mappings": "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",
  "names": ["Entity", "parent", "parentE", "el", "other", "node", "nextOfMe", "Root", "source", "child", "Group", "i", "a", "b", "cur", "index", "Dom", "Text", "value", "HelloWorld", "Component", "mode", "condition", "Invoke", "component", "slots", "attrs", "newSlot", "name", "callback", "If", "newCond", "StackWeb", "js_default"]
}
